                                              Destructors 
What is a Destructor?

A destructor is a special member function of a class that is automatically called when an object goes out of scope or is explicitly deleted. It is used to free resources like dynamically allocated memory, file handles, or network connections.

Key Features of Destructors
‚úî Same name as the class, prefixed with ~
‚úî No return type (not even void)
‚úî No parameters (cannot be overloaded)
‚úî Automatically called when an object is destroyed

Objects which are invoked statically , for them destructor will be called automatically weather it is user defined or in built

But for dynamically created objects , we have to manually call the destructor .

class MyClass {
public:
    ~MyClass() {  // Destructor
        cout << "Destructor called!" << endl;
    }
};

Why Do We Need Destructors?

-> Memory management: Prevents memory leaks by releasing heap-allocated memory.
-> Resource deallocation: Releases file handles, sockets, database connections, etc..
-> Automatic cleanup: Ensures RAII (Resource Acquisition Is Initialization).

Types of Destructors

1Ô∏è‚É£ Default Destructor

If no destructor is defined, the compiler provides a default destructor.
Performs a shallow cleanup (does not free dynamically allocated memory).

2Ô∏è‚É£ User-Defined Destructor
Needed when a class manages dynamic memory or external resources.

3Ô∏è‚É£ Virtual Destructor (For Polymorphism)
When a base class has a pointer to a derived class, the destructor must be virtual to ensure proper cleanup.

SDE Interview Questions on 

Basic Questions

1Ô∏è‚É£ What is a destructor in C++?

A destructor is a special member function that is automatically called when an object is destroyed.
Used for releasing memory and resources.

2Ô∏è‚É£ Can we overload a destructor?

‚ùå No, destructors cannot be overloaded because a class can only have one destructor.

3Ô∏è‚É£ When is a destructor called?

When an object goes out of scope.
When delete is used for heap-allocated objects.
When std::unique_ptr or std::shared_ptr automatically destroys an object.

Intermediate Questions

4Ô∏è‚É£ What happens if a destructor is not defined?

The default destructor is generated by the compiler, which does not free dynamically allocated memory.
This leads to memory leaks.

5Ô∏è‚É£ Why do we need virtual destructors in inheritance?

To ensure proper cleanup when deleting a derived class object using a base class pointer.
Without a virtual destructor, only the base destructor will be called, causing memory leaks.

6Ô∏è‚É£ What is the role of destructors in RAII (Resource Acquisition Is Initialization)?

RAII ensures that resources are acquired in the constructor and released in the destructor, preventing resource leaks.
Example: Smart pointers (std::unique_ptr) automatically release memory in the destructor.

Advanced Questions

7Ô∏è‚É£ What is the difference between delete and delete[] in destructors?

int* arr = new int[5];
delete arr;   // ‚ùå Only deletes the first element (Memory leak!)
delete[] arr; // ‚úÖ Properly deletes the whole array

8Ô∏è‚É£ What happens when a destructor throws an exception?

If a destructor throws an exception during stack unwinding, it causes std::terminate(), crashing the program.
Best practice: Destructors should never throw exceptions.

9Ô∏è‚É£ How does a destructor work in a Singleton class?

Singleton destructors are private to prevent accidental deletion.

class Singleton {

private:

    static Singleton* instance;
    Singleton() {}  // Private constructor
    ~Singleton() {} // Private destructor

public:
    static Singleton* getInstance() {
        if (!instance) instance = new Singleton();
        return instance;
    }
};

üîü How do smart pointers (std::unique_ptr) manage destructors?

std::unique_ptr automatically calls the destructor when it goes out of scope, preventing memory leaks.


Virtual keyword 

The virtual keyword in C++ is primarily used in polymorphism to allow function overriding in derived classes. It ensures that the correct function is called for an object, regardless of the reference type used to point to it.






